digraph "classes" {
rankdir=BT
charset="utf-8"
"msppy_chen.sddp_me_test.Direction" [color="black", fontcolor="black", label=<{Direction|name<br ALIGN="LEFT"/>|}>, shape="record", style="solid"];
"msppy_chen.evaluation.Evaluation" [color="black", fontcolor="black", label=<{Evaluation|n_sample_paths : NoneType<br ALIGN="LEFT"/>sample_path_idx<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.evaluation.EvaluationTrue" [color="black", fontcolor="black", label=<{EvaluationTrue|n_sample_paths : NoneType<br ALIGN="LEFT"/>solve_true : bool<br ALIGN="LEFT"/>|run()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.solver_detail.Extensive" [color="black", fontcolor="black", label=<{Extensive|MSP<br ALIGN="LEFT"/>construction_time : NoneType<br ALIGN="LEFT"/>extensive_model : NoneType<br ALIGN="LEFT"/>first_stage_all_solution<br ALIGN="LEFT"/>first_stage_cost<br ALIGN="LEFT"/>first_stage_solution<br ALIGN="LEFT"/>solving_time : NoneType<br ALIGN="LEFT"/>start : int<br ALIGN="LEFT"/>total_time : NoneType<br ALIGN="LEFT"/>|solve(log_to_console: bool, start: int, flag_rolling: bool): tuple<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.sddp_me_test.GenerateSampleScenaro" [color="black", fontcolor="black", label=<{GenerateSampleScenaro|T<br ALIGN="LEFT"/>distribution_type : str<br ALIGN="LEFT"/>parameters<br ALIGN="LEFT"/>sample_nums : list[int]<br ALIGN="LEFT"/>trunQuantile : float<br ALIGN="LEFT"/>|generate_sample()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.msm.MSIP" [color="black", fontcolor="black", label=<{MSIP|bin_stage : int<br ALIGN="LEFT"/>isMIP<br ALIGN="LEFT"/>models<br ALIGN="LEFT"/>n_binaries : list<br ALIGN="LEFT"/>n_states<br ALIGN="LEFT"/>precision : int<br ALIGN="LEFT"/>|binarize(precision: int, bin_stage: int): None<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.msm.MSLP" [color="black", fontcolor="black", label=<{MSLP|Markov_states : NoneType, list[list[list[float]]]<br ALIGN="LEFT"/>Markovian_uncertainty : NoneType<br ALIGN="LEFT"/>Markovian_uncertainty_function : Callable, NoneType<br ALIGN="LEFT"/>T : int<br ALIGN="LEFT"/>a : float \| ArrayLike, int<br ALIGN="LEFT"/>bound : NoneType<br ALIGN="LEFT"/>dim_Markov_states : dict<br ALIGN="LEFT"/>discount : float<br ALIGN="LEFT"/>flag_CTG : bool<br ALIGN="LEFT"/>flag_infinity : bool<br ALIGN="LEFT"/>flag_updated : bool, int<br ALIGN="LEFT"/>individual_type : str<br ALIGN="LEFT"/>l : float \| ArrayLike, int<br ALIGN="LEFT"/>measure : str<br ALIGN="LEFT"/>models : NoneType<br ALIGN="LEFT"/>n_Markov_states : NoneType, int<br ALIGN="LEFT"/>n_samples : list<br ALIGN="LEFT"/>n_states : list<br ALIGN="LEFT"/>sense : int<br ALIGN="LEFT"/>transition_matrix : NoneType<br ALIGN="LEFT"/>type : str<br ALIGN="LEFT"/>|add_MC_uncertainty_continuous(Markovian_uncertainty: Callable)<br ALIGN="LEFT"/>add_MC_uncertainty_discrete(Markov_states: list[list[list[float]]], transition_matrix: list[list[list[float]]]): None<br ALIGN="LEFT"/>check_markov_copy_models_update_nums(): None<br ALIGN="LEFT"/>check_sample_path_dimension()<br ALIGN="LEFT"/>check_state_and_continuous_discretized()<br ALIGN="LEFT"/>compute_current_node_weight(sample_path: list \| list[list]): float<br ALIGN="LEFT"/>compute_weight_sample_path(sample_path: list \| list[list], start: int): float<br ALIGN="LEFT"/>discretize(n_samples: int, random_state: numpy.random.RandomState \| int \| None, replace: bool, n_Markov_states, method: str, n_sample_paths, Markov_states, transition_matrix, int_flag)<br ALIGN="LEFT"/>enumerate_sample_paths(T: int, start: int, flag_rolling: bool): tuple[int, list]<br ALIGN="LEFT"/>get_stage_cost(m: StochasticModel, t: int): float<br ALIGN="LEFT"/>get_state_solution(m: StochasticModel, t: int): list[float]<br ALIGN="LEFT"/>set_AVaR(l: float \| ArrayLike, a: float \| ArrayLike, method: str): None<br ALIGN="LEFT"/>update()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.sddp_me_test.MSP" [color="black", fontcolor="black", label=<{MSP|T : int<br ALIGN="LEFT"/>models<br ALIGN="LEFT"/>obj_direction : str<br ALIGN="LEFT"/>|set_models()<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.solver_detail.SDDP" [color="black", fontcolor="black", label=<{SDDP|a<br ALIGN="LEFT"/>biased_sampling : bool<br ALIGN="LEFT"/>bounds<br ALIGN="LEFT"/>cut_T : int<br ALIGN="LEFT"/>cut_type : list[str]<br ALIGN="LEFT"/>cut_type_list : list[list[str]]<br ALIGN="LEFT"/>first_stage_solution<br ALIGN="LEFT"/>forward_T : int<br ALIGN="LEFT"/>iteration : int<br ALIGN="LEFT"/>jobs : list<br ALIGN="LEFT"/>l<br ALIGN="LEFT"/>msp<br ALIGN="LEFT"/>n_processes : int<br ALIGN="LEFT"/>n_steps : int<br ALIGN="LEFT"/>obj_bound : list<br ALIGN="LEFT"/>percentile : int<br ALIGN="LEFT"/>policy_value : list<br ALIGN="LEFT"/>rgl_a : Optional[float]<br ALIGN="LEFT"/>rgl_b : Optional[float]<br ALIGN="LEFT"/>rgl_center<br ALIGN="LEFT"/>rgl_norm : Optional[str]<br ALIGN="LEFT"/>total_time : Optional[float], int<br ALIGN="LEFT"/>|plot_bounds(start, window, smooth, ax)<br ALIGN="LEFT"/>solve(n_processes: int, n_steps: int, max_iterations: int, max_stable_iterations: int, max_time: float, tol: float, freq_evaluations: int, percentile: int, tol_diff: float, freq_comparisons: int, n_simulations: int, evaluation_true_flag: bool, query_vars: list, query_T: int, query_constraints: list, query_stage_cost_flag: bool, query_policy_value_flag: bool, freq_clean: int \| list, logToFile_flag: bool, logToConsole_flag: bool, directory: str, rgl_norm: str, rgl_a: float, rgl_b: float)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.solver_detail.SDDiP" [color="black", fontcolor="black", label=<{SDDiP|cut_pattern : NoneType, Optional[dict]<br ALIGN="LEFT"/>cut_type : list[str]<br ALIGN="LEFT"/>cut_type_list<br ALIGN="LEFT"/>level_max_iterations : NoneType, int<br ALIGN="LEFT"/>level_max_stable_iterations : NoneType, int<br ALIGN="LEFT"/>level_max_time : NoneType, int<br ALIGN="LEFT"/>level_mip_gap : NoneType, float<br ALIGN="LEFT"/>level_step_size : NoneType, float<br ALIGN="LEFT"/>level_tol : NoneType, float<br ALIGN="LEFT"/>relax_stage_start_index : NoneType<br ALIGN="LEFT"/>|solve(cuts: list[str], pattern: Optional[dict], relax_stage_start_index: int, level_step_size: float, level_max_stable_iterations: int, level_max_iterations: int, level_max_time: int, level_mip_gap: float, level_tol: float)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.sm_detail.StochasticModel" [color="black", fontcolor="black", label=<{StochasticModel|Markovian_dim_index : list<br ALIGN="LEFT"/>alpha : NoneType<br ALIGN="LEFT"/>controls<br ALIGN="LEFT"/>cuts<br ALIGN="LEFT"/>flag_discretized : int<br ALIGN="LEFT"/>link_constrs : list<br ALIGN="LEFT"/>local_copies : NoneType, list<br ALIGN="LEFT"/>local_copies_original_space : NoneType, list<br ALIGN="LEFT"/>measure<br ALIGN="LEFT"/>n_samples : int<br ALIGN="LEFT"/>n_samples_discrete<br ALIGN="LEFT"/>n_states : int<br ALIGN="LEFT"/>n_states_original_space : NoneType, int<br ALIGN="LEFT"/>probability : NoneType<br ALIGN="LEFT"/>states : NoneType, list<br ALIGN="LEFT"/>states_original_space : NoneType, list<br ALIGN="LEFT"/>type : str<br ALIGN="LEFT"/>uncertainty_coef<br ALIGN="LEFT"/>uncertainty_coef_continuous : dict<br ALIGN="LEFT"/>uncertainty_coef_dependent<br ALIGN="LEFT"/>uncertainty_coef_discrete<br ALIGN="LEFT"/>uncertainty_mix_continuous : dict<br ALIGN="LEFT"/>uncertainty_obj<br ALIGN="LEFT"/>uncertainty_obj_continuous : dict<br ALIGN="LEFT"/>uncertainty_obj_dependent<br ALIGN="LEFT"/>uncertainty_obj_discrete<br ALIGN="LEFT"/>uncertainty_rhs<br ALIGN="LEFT"/>uncertainty_rhs_continuous : dict<br ALIGN="LEFT"/>uncertainty_rhs_dependent<br ALIGN="LEFT"/>uncertainty_rhs_discrete<br ALIGN="LEFT"/>|addConstr(constr: any, sense: str, rhs: float \| gurobipy.Var \| gurobipy.LinExpr, name: str, uncertainty: Callable \| ArrayLike \| Mapping, uncertainty_dependent: int \| ArrayLike \| Mapping): gurobipy.Constr<br ALIGN="LEFT"/>addConstrs(generator: Generator, name: str, uncertainty: Callable \| ArrayLike \| Mapping, uncertainty_dependent: int \| ArrayLike \| Mapping): gurobipy.tupledict<br ALIGN="LEFT"/>addStateVar(lb: float, ub: float, obj: float, vtype: str, name: str, column: gurobipy.Column, uncertainty: Callable \| ArrayLike \| Mapping, uncertainty_dependent: int \| ArrayLike \| Mapping): tuple[gurobipy.Var, gurobipy.Var]<br ALIGN="LEFT"/>addStateVars(): tuple[gurobipy.tupledict, gurobipy.tupledict]<br ALIGN="LEFT"/>addVar(lb: float, ub: float, obj: float, vtype: str, name: str, column: gurobipy.Column, uncertainty: Callable \| ArrayLike \| Mapping, uncertainty_dependent: int \| ArrayLike \| Mapping): gurobipy.Var<br ALIGN="LEFT"/>addVars(): gurobipy.tupledict<br ALIGN="LEFT"/>add_cut(rhs: float \| gurobipy.LinExpr, gradient: ArrayLike)<br ALIGN="LEFT"/>average(objLP_samples: ArrayLike, gradLP_samples: ArrayLike, probability: list): tuple[float, float]<br ALIGN="LEFT"/>back_binarize(transition: bool)<br ALIGN="LEFT"/>binarize(precision: int, n_binaries: list[int], transition: bool)<br ALIGN="LEFT"/>copy()<br ALIGN="LEFT"/>delete_CTG()<br ALIGN="LEFT"/>delete_link_constrs(): None<br ALIGN="LEFT"/>relax()<br ALIGN="LEFT"/>sample_uncertainty(randomState_instance: any): None<br ALIGN="LEFT"/>set_probability(probability: ArrayLike): None<br ALIGN="LEFT"/>set_up_CTG(discount: float, bound: float)<br ALIGN="LEFT"/>set_up_link_constrs(): None<br ALIGN="LEFT"/>solveLP()<br ALIGN="LEFT"/>update(): None<br ALIGN="LEFT"/>update_link_constrs(fwdSolution: float): None<br ALIGN="LEFT"/>update_uncertainty(k)<br ALIGN="LEFT"/>update_uncertainty_dependent(Markov_state: ArrayLike): None<br ALIGN="LEFT"/>update_uncertainty_discrete(k)<br ALIGN="LEFT"/>write_infeasible_model(text)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.sm_detail.StochasticModelLG" [color="black", fontcolor="black", label=<{StochasticModelLG|link_constrs : list<br ALIGN="LEFT"/>local_copies : NoneType, list<br ALIGN="LEFT"/>local_copies_original_space : NoneType, list<br ALIGN="LEFT"/>n_states : int<br ALIGN="LEFT"/>n_states_original_space : int<br ALIGN="LEFT"/>states : NoneType, list<br ALIGN="LEFT"/>states_original_space : NoneType, list<br ALIGN="LEFT"/>|copy(model)<br ALIGN="LEFT"/>solveLG(gradLPScen, given_bound, objVal_primal, flag_tight, forward_solution, step_size, max_stable_iterations, max_iterations, max_time, MIPGap, tol)<br ALIGN="LEFT"/>solvePrimal(): list<br ALIGN="LEFT"/>solveSB(gradLPScen: ArrayLike): list<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.evaluation._Evaluation" [color="black", fontcolor="black", label=<{_Evaluation|CI : Optional[tuple]<br ALIGN="LEFT"/>MSP<br ALIGN="LEFT"/>exact_policy_value : Optional[float], ndarray<br ALIGN="LEFT"/>gap : Optional[float], int<br ALIGN="LEFT"/>markovian_idx : Optional[list]<br ALIGN="LEFT"/>markovian_samples : Optional[ArrayLike]<br ALIGN="LEFT"/>n_sample_paths : Optional[int]<br ALIGN="LEFT"/>n_simulations : Optional[int]<br ALIGN="LEFT"/>policy_bound : float<br ALIGN="LEFT"/>policy_values : Optional[list], ndarray<br ALIGN="LEFT"/>sample_path_idx : Optional[list]<br ALIGN="LEFT"/>solution : Optional[dict]<br ALIGN="LEFT"/>solution_dual<br ALIGN="LEFT"/>solve_true : bool<br ALIGN="LEFT"/>stage_cost : DataFrame, Optional[ArrayLike]<br ALIGN="LEFT"/>|run(n_simulations: int, percentile: int, query, query_T, query_dual, query_stage_cost, n_processes)<br ALIGN="LEFT"/>run_single(policy_values, jobs, query, query_dual, query_stage_cost, stage_cost, solution, solution_dual)<br ALIGN="LEFT"/>}>, shape="record", style="solid"];
"msppy_chen.evaluation.Evaluation" -> "msppy_chen.evaluation._Evaluation" [arrowhead="empty", arrowtail="none"];
"msppy_chen.evaluation.EvaluationTrue" -> "msppy_chen.evaluation.Evaluation" [arrowhead="empty", arrowtail="none"];
"msppy_chen.msm.MSIP" -> "msppy_chen.msm.MSLP" [arrowhead="empty", arrowtail="none"];
"msppy_chen.sm_detail.StochasticModelLG" -> "msppy_chen.sm_detail.StochasticModel" [arrowhead="empty", arrowtail="none"];
"msppy_chen.solver_detail.SDDiP" -> "msppy_chen.solver_detail.SDDP" [arrowhead="empty", arrowtail="none"];
}
